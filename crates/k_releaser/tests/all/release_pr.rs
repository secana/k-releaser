use crate::helpers::{test_context::TestContext, today};
use cargo_utils::{CARGO_TOML, LocalManifest};

#[tokio::test]
#[cfg_attr(not(feature = "docker-tests"), ignore)]
async fn k_releaser_opens_pr_with_default_config() {
    let context = TestContext::new().await;

    // Enable CHANGELOG.md file creation for this test
    let config = r#"
    [workspace]
    changelog_update = true
    "#;
    context.write_release_plz_toml(config);

    context.run_release_pr().success();
    let _today = today();

    let opened_prs = context.opened_release_prs().await;
    assert_eq!(opened_prs.len(), 1);
    assert_eq!(opened_prs[0].title, "chore: release v0.1.1");
    let package = &context.gitea.repo;
    assert_eq!(
        opened_prs[0].body.as_ref().unwrap().trim(),
        format!(
            r"
## New release v0.1.1

This release updates all workspace packages to version **0.1.1**.

### Packages updated

* `{package}`


<details><summary><i><b>Changelog</b></i></summary>

### Fixed

- add config file
- cargo init

### Other

- Initial commit

</details>




---
Generated by [k-releaser](https://github.com/secana/k-releaser/)",
        )
        .trim()
    );
}

#[tokio::test]
#[cfg_attr(not(feature = "docker-tests"), ignore)]
async fn k_releaser_opens_pr_without_breaking_changes() {
    // Semver checking not needed - version bumps determined by conventional commits
    let context = TestContext::new().await;

    // Enable CHANGELOG.md file creation for this test
    let config = r#"
    [workspace]
    changelog_update = true
    "#;
    context.write_release_plz_toml(config);

    let lib_file = context.repo_dir().join("src").join("lib.rs");

    let write_lib_file = |content: &str, commit_message: &str| {
        fs_err::write(&lib_file, content).unwrap();
        context.push_all_changes(commit_message);
    };

    write_lib_file("pub fn foo() {}", "feat: add lib");

    context.run_release_pr().success();
    context.merge_release_pr().await;
    context.run_release().success();

    write_lib_file(
        "pub fn foo() {println!(\"hello\");}",
        "fix: edit lib with compatible change",
    );

    context.run_release_pr().success();
    let _today = today();

    let opened_prs = context.opened_release_prs().await;
    assert_eq!(opened_prs.len(), 1);
    assert_eq!(opened_prs[0].title, "chore: release v0.1.2");
    let package = &context.gitea.repo;
    let pr_body = opened_prs[0].body.as_ref().unwrap().trim();
    pretty_assertions::assert_eq!(
        pr_body,
        format!(
            r"
## New release v0.1.2

This release updates all workspace packages to version **0.1.2**.

### Packages updated

* `{package}`


<details><summary><i><b>Changelog</b></i></summary>

### Fixed

- edit lib with compatible change

</details>




---
Generated by [k-releaser](https://github.com/secana/k-releaser/)",
        )
        .trim()
    );
}

#[tokio::test]
#[cfg_attr(not(feature = "docker-tests"), ignore)]
async fn k_releaser_should_fail_for_multi_package_pr() {
    let context = TestContext::new_workspace(&["one", "two"]).await;

    let config = r#"
    [workspace]
    pr_name = "release: {{ package }} {{ version }}"
    "#;

    context.write_release_plz_toml(config);
    // With unified workspace versioning, multi-package workspaces use "workspace" as the package name
    let _outcome = context.run_release_pr().success();

    let opened_prs = context.opened_release_prs().await;
    assert_eq!(opened_prs.len(), 1);
    assert_eq!(opened_prs[0].title, "release: workspace 0.1.1");
}

#[tokio::test]
#[cfg_attr(not(feature = "docker-tests"), ignore)]
async fn k_releaser_detects_edited_readme_cargo_toml_field() {
    let context = TestContext::new().await;

    // Enable CHANGELOG.md file creation for this test
    let config = r#"
    [workspace]
    changelog_update = true
    "#;
    context.write_release_plz_toml(config);

    context.run_release_pr().success();
    context.merge_release_pr().await;

    let expected_tag = "v0.1.1";

    context.run_release().success();

    let gitea_release = context.gitea.get_gitea_release(expected_tag).await;
    assert_eq!(gitea_release.name, expected_tag);

    move_readme(&context, "fix: move readme");

    context.run_release_pr().success();
    context.merge_release_pr().await;

    let expected_tag = "v0.1.2";

    context.run_release().success();

    let gitea_release = context.gitea.get_gitea_release(expected_tag).await;
    assert_eq!(gitea_release.name, expected_tag);
    expect_test::expect![[r"
        ### Fixed

        - move readme"]]
    .assert_eq(&gitea_release.body);
}

#[tokio::test]
#[cfg_attr(not(feature = "docker-tests"), ignore)]
async fn k_releaser_honors_features_always_increment_minor_flag() {
    let context = TestContext::new().await;

    let config = r"
    [workspace]
    changelog_update = true
    features_always_increment_minor = true
    ";
    context.write_release_plz_toml(config);

    context.run_release_pr().success();
    context.merge_release_pr().await;

    let expected_tag = "v0.1.1";

    context.run_release().success();

    let gitea_release = context.gitea.get_gitea_release(expected_tag).await;
    assert_eq!(gitea_release.name, expected_tag);

    move_readme(&context, "feat: move readme");

    let outcome = context.run_release_pr().success();

    let opened_prs = context.opened_release_prs().await;
    let open_pr = &opened_prs[0];
    let expected_stdout = serde_json::json!({
        "prs": [{
            "base_branch": "main",
            "head_branch": open_pr.branch(),
            "html_url": open_pr.html_url,
            "number": open_pr.number,
            "releases": [{
                "package_name": context.gitea.repo,
                "version": "0.2.0"
            }]
        }]
    });
    outcome.stdout(format!("{expected_stdout}\n"));
    context.merge_release_pr().await;

    let expected_tag = "v0.2.0";

    context.run_release().success();

    let gitea_release = context.gitea.get_gitea_release(expected_tag).await;
    assert_eq!(gitea_release.name, expected_tag);
    expect_test::expect![[r"
        ### Added

        - move readme"]]
    .assert_eq(&gitea_release.body);
}

#[tokio::test]
#[cfg(unix)]
#[cfg_attr(not(feature = "docker-tests"), ignore)]
async fn k_releaser_adds_labels_to_release_pr() {
    let test_context = TestContext::new().await;

    // Initial PR setup with two labels
    let initial_config = r#"
    [workspace]
    pr_labels = ["bug", "enhancement"]
    "#;
    let initial_labels = ["bug", "enhancement"];

    test_context.write_release_plz_toml(initial_config);
    test_context.run_release_pr().success();

    let initial_prs = test_context.opened_release_prs().await;
    assert_eq!(initial_prs.len(), 1, "Expected one PR to be created");

    let initial_pr = &initial_prs[0];
    assert_eq!(initial_pr.labels.len(), 2, "Expected 2 labels");

    assert_eq!(
        initial_pr.label_names(),
        initial_labels,
        "Labels don't match expected values"
    );

    // Update PR with additional label
    let updated_config = r#"
    [workspace]
    pr_name = "add labels to release label update"
    pr_labels = ["needs-testing"]
    "#;
    let expected_labels = ["bug", "enhancement", "needs-testing"];

    test_context.write_release_plz_toml(updated_config);
    test_context.run_release_pr().success();

    let updated_prs = test_context.opened_release_prs().await;
    assert_eq!(updated_prs.len(), 1, "Expected one PR after update");

    let updated_pr = &updated_prs[0];
    assert_eq!(updated_pr.title, "add labels to release label update");
    assert_eq!(updated_pr.labels.len(), 3, "Expected 3 labels after update");

    assert_eq!(
        updated_pr.label_names(),
        expected_labels,
        "Updated labels don't match expected values"
    );
}

#[tokio::test]
#[cfg_attr(not(feature = "docker-tests"), ignore)]
async fn k_releaser_doesnt_add_invalid_labels_to_release_pr() {
    let test_context = TestContext::new().await;
    let test_cases: &[(&str, &str)] = &[
        // (label config, expected error message)
        (
            r#"
            [workspace]
            pr_labels = [" "]
        "#,
            "leading or trailing whitespace is not allowed",
        ), // space label
        (
            r#"
            [workspace]
            pr_labels = ["this-is-a-very-long-label-that-exceeds-the-maximum-length-allowed-by-git-providers"]
            "#,
            "it exceeds maximum length of 50 characters",
        ), // Too long
        (
            r#"
            [workspace]
            pr_labels = [""]
            "#,
            "empty labels are not allowed",
        ),
        (
            r#"
            [workspace]
            pr_labels = ["abc", "abc"]
            "#,
            "duplicate labels are not allowed",
        ),
    ];

    for test_case in test_cases {
        let initial_config = test_case.0;
        test_context.write_release_plz_toml(initial_config);
        let error = test_context.run_release_pr().failure().to_string();
        assert!(
            error.contains("Failed to add label") && error.contains(test_case.1),
            "Expected label creation failure got: {error}"
        );
    }
}

fn move_readme(context: &TestContext, message: &str) {
    let readme = "README.md";
    let new_readme = format!("NEW_{readme}");
    let old_readme_path = context.repo_dir().join(readme);
    let new_readme_path = context.repo_dir().join(&new_readme);
    fs_err::rename(old_readme_path, new_readme_path).unwrap();

    update_readme_in_cargo_toml(context, &new_readme);

    context.push_all_changes(message);
}

fn update_readme_in_cargo_toml(context: &TestContext, readme_path: &str) {
    let cargo_toml_path = context.repo_dir().join(CARGO_TOML);
    let mut cargo_toml = LocalManifest::try_new(&cargo_toml_path).unwrap();
    cargo_toml.data["package"]["readme"] = toml_edit::value(readme_path);
    cargo_toml.write().unwrap();
}

#[tokio::test]
#[cfg_attr(not(feature = "docker-tests"), ignore)]
async fn k_releaser_handles_invalid_readme_path_gracefully() {
    let context = TestContext::new().await;

    // Enable CHANGELOG.md file creation for this test
    let config = r#"
    [workspace]
    changelog_update = true
    "#;
    context.write_release_plz_toml(config);

    // Set up a README path that will be invalid when the package is installed
    // This simulates the real-world scenario where someone sets a relative path
    // like "../../README.md" in their Cargo.toml, which works locally but fails
    // when the package is installed from the registry cache
    let cargo_toml_path = context.repo_dir().join(CARGO_TOML);
    let mut cargo_toml = LocalManifest::try_new(&cargo_toml_path).unwrap();

    // Create a README file in the project root for local development
    let readme_content = "# My Project\n\nThis is a test project.";
    let actual_readme_path = context.repo_dir().join("README.md");
    fs_err::write(&actual_readme_path, readme_content).unwrap();

    // Set an invalid relative path that would work locally but fail in registry cache
    // This is the problematic pattern that users might accidentally use
    cargo_toml.data["package"]["readme"] = toml_edit::value("../../README.md");
    cargo_toml.write().unwrap();

    context.push_all_changes("set invalid readme path");

    // This should not panic or fail due to the invalid readme path
    // The fix should handle this gracefully by logging a warning and continuing
    let outcome = context.run_release_pr().success();

    let opened_prs = context.opened_release_prs().await;
    assert_eq!(
        opened_prs.len(),
        1,
        "Release PR should still be created despite invalid readme path"
    );

    let open_pr = &opened_prs[0];
    assert_eq!(open_pr.title, "chore: release v0.1.1");

    // Verify the PR was created successfully
    let expected_stdout = serde_json::json!({
        "prs": [{
            "head_branch": open_pr.branch(),
            "base_branch": "main",
            "html_url": open_pr.html_url,
            "number": open_pr.number,
            "releases": [{
                "package_name": context.gitea.repo,
                "version": "0.1.1"
            }]
        }]
    });
    outcome.stdout(format!("{expected_stdout}\n"));

    // Additional test: Make a change and ensure subsequent operations work
    let new_file = context.repo_dir().join("src").join("new.rs");
    fs_err::write(&new_file, "// new functionality").unwrap();
    context.push_all_changes("feat: add new functionality");

    // This should also work without issues
    context.run_update().success();

    // Verify changelog was updated despite the invalid readme path
    let changelog = fs_err::read_to_string(context.repo_dir().join("CHANGELOG.md")).unwrap();
    assert!(
        changelog.contains("add new functionality"),
        "Changelog should be updated even with invalid readme path"
    );
}

#[tokio::test]
#[cfg_attr(not(feature = "docker-tests"), ignore)]
async fn k_releaser_handles_nonexistent_readme_path_in_cargo_toml() {
    let context = TestContext::new().await;

    // Set a README path that simply doesn't exist anywhere
    let cargo_toml_path = context.repo_dir().join(CARGO_TOML);
    let mut cargo_toml = LocalManifest::try_new(&cargo_toml_path).unwrap();
    cargo_toml.data["package"]["readme"] = toml_edit::value("nonexistent-readme.md");
    cargo_toml.write().unwrap();

    context.push_all_changes("set nonexistent readme path");

    // This should handle the nonexistent file gracefully
    let _outcome = context.run_release_pr().success();

    let opened_prs = context.opened_release_prs().await;
    assert_eq!(
        opened_prs.len(),
        1,
        "Release PR should be created despite nonexistent readme"
    );

    // Make sure subsequent operations work
    let new_file = context.repo_dir().join("src").join("lib.rs");
    fs_err::write(&new_file, "pub fn test() {}").unwrap();
    context.push_all_changes("add lib function");

    context.run_update().success();
}

#[tokio::test]
#[cfg_attr(not(feature = "docker-tests"), ignore)]
async fn k_releaser_works_with_valid_readme_path() {
    let context = TestContext::new().await;

    // Create a valid README and set correct path
    let readme_content = "# Valid Project\n\nThis project has a valid readme path.";
    let readme_path = context.repo_dir().join("README.md");
    fs_err::write(&readme_path, readme_content).unwrap();

    let cargo_toml_path = context.repo_dir().join(CARGO_TOML);
    let mut cargo_toml = LocalManifest::try_new(&cargo_toml_path).unwrap();
    cargo_toml.data["package"]["readme"] = toml_edit::value("README.md");
    cargo_toml.write().unwrap();

    context.push_all_changes("add valid readme");

    // This should work normally
    let _outcome = context.run_release_pr().success();

    let opened_prs = context.opened_release_prs().await;
    assert_eq!(opened_prs.len(), 1);

    // Modify the README and ensure it's detected as a change
    fs_err::write(
        &readme_path,
        "# Updated Valid Project\n\nThis readme was updated.",
    )
    .unwrap();
    context.push_all_changes("update readme content");

    context.run_release_pr().success();

    // Should create a new PR for the readme change
    let updated_prs = context.opened_release_prs().await;
    // The count might be 1 (updated) or 2 (new PR), both are valid depending on implementation
    assert!(
        !updated_prs.is_empty(),
        "Should handle readme updates correctly"
    );
}

#[tokio::test]
#[cfg_attr(not(feature = "docker-tests"), ignore)]
async fn changelog_is_updated_correctly_if_no_new_line_after_h1() {
    let context = TestContext::new().await;

    // Enable CHANGELOG.md file creation for this test
    let config = r#"
    [workspace]
    changelog_update = true
    "#;
    context.write_release_plz_toml(config);

    let changelog = "# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]
";

    context.write_changelog(changelog);
    context.run_release_pr().success();
    // Merge release PR to update changelog of v0.1.0 of crate
    context.merge_release_pr().await;

    let new_changelog = context.read_changelog();
    let username = context.gitea.user.username();
    let repo = &context.gitea.repo;
    let _today = today();

    assert_eq!(
        new_changelog,
        format!(
            r"# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.1.1](https://localhost/{username}/{repo}/compare/v0.1.0...v0.1.1) - {_today}

### Fixed

- add config file
- cargo init

### Other

- edit changelog
- Initial commit
"
        )
    );
}
