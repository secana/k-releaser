use crate::{
    PackagesUpdate, ReleaseInfo,
    tera::{RELEASES_VAR, VERSION_VAR, render_template},
};
use chrono::SecondsFormat;

pub const DEFAULT_BRANCH_PREFIX: &str = "k-releaser-";
pub const OLD_BRANCH_PREFIX: &str = "release-plz/";
pub const DEFAULT_PR_BODY_TEMPLATE: &str = r#"
## New release v{{ releases[0].next_version }}

This release updates all workspace packages to version **{{ releases[0].next_version }}**.

### Packages updated
{% for release in releases %}
* `{{ release.package }}`
{%- endfor %}

{% if releases[0].changelog %}
<details><summary><i><b>Changelog</b></i></summary>

{{ releases[0].changelog }}

</details>
{% endif %}

{% if releases[0].remote and releases[0].remote.contributors %}
### Contributors

{% for contributor in releases[0].remote.contributors %}
* @{{ contributor.username }}
{%- endfor %}
{% endif %}

---
Generated by [k-releaser](https://github.com/secana/k-releaser/)
"#;

#[derive(Debug)]
pub struct Pr {
    pub base_branch: String,
    pub branch: String,
    pub title: String,
    pub body: String,
    pub draft: bool,
    pub labels: Vec<String>,
}

impl Pr {
    pub fn new(
        default_branch: &str,
        packages_to_update: &PackagesUpdate,
        project_contains_multiple_pub_packages: bool,
        branch_prefix: &str,
        title_template: Option<String>,
        body_template: Option<&str>,
    ) -> anyhow::Result<Self> {
        let pr = Self {
            branch: release_branch(branch_prefix),
            base_branch: default_branch.to_string(),
            title: pr_title(
                packages_to_update,
                project_contains_multiple_pub_packages,
                title_template,
            )?,
            body: pr_body(packages_to_update, body_template)?,
            draft: false,
            labels: vec![],
        };
        Ok(pr)
    }

    pub fn mark_as_draft(mut self, draft: bool) -> Self {
        self.draft = draft;
        self
    }

    pub fn with_labels(mut self, labels: Vec<String>) -> Self {
        self.labels = labels;
        self
    }
}

fn release_branch(prefix: &str) -> String {
    let now = chrono::offset::Utc::now();
    // Convert to a string of format "2018-01-26T18:30:09Z".
    let now = now.to_rfc3339_opts(SecondsFormat::Secs, true);
    // ':' is not a valid character for a branch name.
    let now = now.replace(':', "-");
    format!("{prefix}{now}")
}

fn pr_title(
    packages_to_update: &PackagesUpdate,
    _project_contains_multiple_pub_packages: bool,
    title_template: Option<String>,
) -> anyhow::Result<String> {
    let updates = packages_to_update.updates();

    // With unified workspace versioning, all packages always have the same version
    let workspace_version = &updates[0].1.version;

    let title = if let Some(title_template) = title_template {
        let mut context = tera::Context::new();
        // Always include version since all packages share it
        context.insert(VERSION_VAR, workspace_version.to_string().as_str());
        // For single-package projects or backward compatibility, include package name
        // Use first package name (for single-package) or "workspace" for multi-package
        let package_name = if updates.len() == 1 {
            updates[0].0.name.as_str()
        } else {
            "workspace"
        };
        context.insert("package", package_name);
        render_template(&title_template, &context, "pr_name")?
    } else {
        // For unified workspace versioning, always use simple format
        format!("chore: release v{workspace_version}")
    };
    Ok(title)
}

/// The Github API allows a max of 65536 characters in the body field when trying to create a new PR
const MAX_BODY_LEN: usize = 65536;

fn pr_body(
    packages_to_update: &PackagesUpdate,
    body_template: Option<&str>,
) -> anyhow::Result<String> {
    let body_template = body_template.unwrap_or(DEFAULT_PR_BODY_TEMPLATE);

    let mut releases = packages_to_update.releases();
    let first_render = render_pr_body(&releases, body_template)?;

    if first_render.chars().count() > MAX_BODY_LEN {
        tracing::info!(
            "PR body is longer than {MAX_BODY_LEN} characters. Omitting full changelog."
        );

        releases.iter_mut().for_each(|release| {
            release.changelog = None;
            release.title = None;
        });

        render_pr_body(&releases, body_template)
    } else {
        Ok(first_render)
    }
}

fn render_pr_body(releases: &[ReleaseInfo], body_template: &str) -> anyhow::Result<String> {
    let mut context = tera::Context::new();
    context.insert(RELEASES_VAR, releases);

    let rendered_body = render_template(body_template, &context, "pr_body")?;
    Ok(trim_pr_body(rendered_body))
}

fn trim_pr_body(body: String) -> String {
    // Make extra sure the body is short enough.
    // If it's not, give up trying to fail gracefully by truncating it to the nearest valid UTF-8 boundary.
    // A grapheme cluster may be cut in half in the process.

    if body.chars().count() > MAX_BODY_LEN {
        tracing::warn!("PR body is still longer than {MAX_BODY_LEN} characters. Truncating as is.");
        body.chars().take(MAX_BODY_LEN).collect()
    } else {
        body
    }
}
